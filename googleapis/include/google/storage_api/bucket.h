// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Cloud Storage JSON API (storage/v1)
// Generated from:
//   Version: v1
//   Revision: 20170504
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.4
#ifndef  GOOGLE_STORAGE_API_BUCKET_H_
#define  GOOGLE_STORAGE_API_BUCKET_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/client/util/date_time.h"
#include "googleapis/strings/stringpiece.h"

#include "google/storage_api/bucket_access_control.h"
#include "google/storage_api/object_access_control.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_storage_api {
using namespace googleapis;

/**
 * A bucket.
 *
 * @ingroup DataObject
 */
class Bucket : public client::JsonCppData {
 public:
  /**
   * The bucket's billing configuration.
   *
   * @ingroup DataObject
   */
  class BucketBilling : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketBilling* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketBilling(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketBilling(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketBilling();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketBilling</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketBilling");
    }

    /**
     * Determine if the '<code>requesterPays</code>' attribute was set.
     *
     * @return true if the '<code>requesterPays</code>' attribute was set.
     */
    bool has_requester_pays() const {
      return Storage().isMember("requesterPays");
    }

    /**
     * Clears the '<code>requesterPays</code>' attribute.
     */
    void clear_requester_pays() {
      MutableStorage()->removeMember("requesterPays");
    }


    /**
     * Get the value of the '<code>requesterPays</code>' attribute.
     */
    bool get_requester_pays() const {
      const Json::Value& storage = Storage("requesterPays");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>requesterPays</code>' attribute.
     *
     * When set to true, bucket is requester pays.
     *
     * @param[in] value The new value.
     */
    void set_requester_pays(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("requesterPays"));
    }

   private:
    void operator=(const BucketBilling&);
  };  // BucketBilling
  /**
   * No description provided.
   *
   * @ingroup DataObject
   */
  class BucketCors : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketCors* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketCors(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketCors(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketCors();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketCors</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketCors");
    }

    /**
     * Determine if the '<code>maxAgeSeconds</code>' attribute was set.
     *
     * @return true if the '<code>maxAgeSeconds</code>' attribute was set.
     */
    bool has_max_age_seconds() const {
      return Storage().isMember("maxAgeSeconds");
    }

    /**
     * Clears the '<code>maxAgeSeconds</code>' attribute.
     */
    void clear_max_age_seconds() {
      MutableStorage()->removeMember("maxAgeSeconds");
    }


    /**
     * Get the value of the '<code>maxAgeSeconds</code>' attribute.
     */
    int32 get_max_age_seconds() const {
      const Json::Value& storage = Storage("maxAgeSeconds");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>maxAgeSeconds</code>' attribute.
     *
     * The value, in seconds, to return in the  Access-Control-Max-Age header
     * used in preflight responses.
     *
     * @param[in] value The new value.
     */
    void set_max_age_seconds(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("maxAgeSeconds"));
    }

    /**
     * Determine if the '<code>method</code>' attribute was set.
     *
     * @return true if the '<code>method</code>' attribute was set.
     */
    bool has_method() const {
      return Storage().isMember("method");
    }

    /**
     * Clears the '<code>method</code>' attribute.
     */
    void clear_method() {
      MutableStorage()->removeMember("method");
    }


    /**
     * Get a reference to the value of the '<code>method</code>' attribute.
     */
    const client::JsonCppArray<string > get_method() const {
       const Json::Value& storage = Storage("method");
      return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>method</code>'
     * property.
     *
     * The list of HTTP methods on which to include CORS response headers, (GET,
     * OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and
     * means "any method".
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppArray<string > mutable_method() {
      Json::Value* storage = MutableStorage("method");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
    }

    /**
     * Determine if the '<code>origin</code>' attribute was set.
     *
     * @return true if the '<code>origin</code>' attribute was set.
     */
    bool has_origin() const {
      return Storage().isMember("origin");
    }

    /**
     * Clears the '<code>origin</code>' attribute.
     */
    void clear_origin() {
      MutableStorage()->removeMember("origin");
    }


    /**
     * Get a reference to the value of the '<code>origin</code>' attribute.
     */
    const client::JsonCppArray<string > get_origin() const {
       const Json::Value& storage = Storage("origin");
      return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>origin</code>'
     * property.
     *
     * The list of Origins eligible to receive CORS response headers. Note: "*"
     * is permitted in the list of origins, and means "any Origin".
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppArray<string > mutable_origin() {
      Json::Value* storage = MutableStorage("origin");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
    }

    /**
     * Determine if the '<code>responseHeader</code>' attribute was set.
     *
     * @return true if the '<code>responseHeader</code>' attribute was set.
     */
    bool has_response_header() const {
      return Storage().isMember("responseHeader");
    }

    /**
     * Clears the '<code>responseHeader</code>' attribute.
     */
    void clear_response_header() {
      MutableStorage()->removeMember("responseHeader");
    }


    /**
     * Get a reference to the value of the '<code>responseHeader</code>'
     * attribute.
     */
    const client::JsonCppArray<string > get_response_header() const {
       const Json::Value& storage = Storage("responseHeader");
      return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>responseHeader</code>'
     * property.
     *
     * The list of HTTP headers other than the simple response headers to give
     * permission for the user-agent to share across domains.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppArray<string > mutable_responseHeader() {
      Json::Value* storage = MutableStorage("responseHeader");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
    }

   private:
    void operator=(const BucketCors&);
  };  // BucketCors
  /**
   * The bucket's lifecycle configuration. See lifecycle management for more
   * information.
   *
   * @ingroup DataObject
   */
  class BucketLifecycle : public client::JsonCppData {
   public:
    /**
     * No description provided.
     *
     * @ingroup DataObject
     */
    class BucketLifecycleRule : public client::JsonCppData {
     public:
      /**
       * The action to take.
       *
       * @ingroup DataObject
       */
      class BucketLifecycleRuleAction : public client::JsonCppData {
       public:
        /**
         * Creates a new default instance.
         *
         * @return Ownership is passed back to the caller.
         */
        static BucketLifecycleRuleAction* New();

        /**
         * Standard constructor for an immutable data object instance.
         *
         * @param[in] storage  The underlying data storage for this instance.
         */
        explicit BucketLifecycleRuleAction(const Json::Value& storage);

        /**
         * Standard constructor for a mutable data object instance.
         *
         * @param[in] storage  The underlying data storage for this instance.
         */
        explicit BucketLifecycleRuleAction(Json::Value* storage);

        /**
         * Standard destructor.
         */
        virtual ~BucketLifecycleRuleAction();

        /**
         * Returns a string denoting the type of this data object.
         *
         * @return <code>google_storage_api::BucketLifecycleRuleAction</code>
         */
        const StringPiece GetTypeName() const {
          return StringPiece("google_storage_api::BucketLifecycleRuleAction");
        }

        /**
         * Determine if the '<code>storageClass</code>' attribute was set.
         *
         * @return true if the '<code>storageClass</code>' attribute was set.
         */
        bool has_storage_class() const {
          return Storage().isMember("storageClass");
        }

        /**
         * Clears the '<code>storageClass</code>' attribute.
         */
        void clear_storage_class() {
          MutableStorage()->removeMember("storageClass");
        }


        /**
         * Get the value of the '<code>storageClass</code>' attribute.
         */
        const StringPiece get_storage_class() const {
          const Json::Value& v = Storage("storageClass");
          if (v == Json::Value::null) return StringPiece("");
          return StringPiece(v.asCString());
        }

        /**
         * Change the '<code>storageClass</code>' attribute.
         *
         * Target storage class. Required iff the type of the action is
         * SetStorageClass.
         *
         * @param[in] value The new value.
         */
        void set_storage_class(const StringPiece& value) {
          *MutableStorage("storageClass") = value.data();
        }

        /**
         * Determine if the '<code>type</code>' attribute was set.
         *
         * @return true if the '<code>type</code>' attribute was set.
         */
        bool has_type() const {
          return Storage().isMember("type");
        }

        /**
         * Clears the '<code>type</code>' attribute.
         */
        void clear_type() {
          MutableStorage()->removeMember("type");
        }


        /**
         * Get the value of the '<code>type</code>' attribute.
         */
        const StringPiece get_type() const {
          const Json::Value& v = Storage("type");
          if (v == Json::Value::null) return StringPiece("");
          return StringPiece(v.asCString());
        }

        /**
         * Change the '<code>type</code>' attribute.
         *
         * Type of the action. Currently, only Delete and SetStorageClass are
         * supported.
         *
         * @param[in] value The new value.
         */
        void set_type(const StringPiece& value) {
          *MutableStorage("type") = value.data();
        }

       private:
        void operator=(const BucketLifecycleRuleAction&);
      };  // BucketLifecycleRuleAction
      /**
       * The condition(s) under which the action will be taken.
       *
       * @ingroup DataObject
       */
      class BucketLifecycleRuleCondition : public client::JsonCppData {
       public:
        /**
         * Creates a new default instance.
         *
         * @return Ownership is passed back to the caller.
         */
        static BucketLifecycleRuleCondition* New();

        /**
         * Standard constructor for an immutable data object instance.
         *
         * @param[in] storage  The underlying data storage for this instance.
         */
        explicit BucketLifecycleRuleCondition(const Json::Value& storage);

        /**
         * Standard constructor for a mutable data object instance.
         *
         * @param[in] storage  The underlying data storage for this instance.
         */
        explicit BucketLifecycleRuleCondition(Json::Value* storage);

        /**
         * Standard destructor.
         */
        virtual ~BucketLifecycleRuleCondition();

        /**
         * Returns a string denoting the type of this data object.
         *
         * @return <code>google_storage_api::BucketLifecycleRuleCondition</code>
         */
        const StringPiece GetTypeName() const {
          return StringPiece("google_storage_api::BucketLifecycleRuleCondition");
        }

        /**
         * Determine if the '<code>age</code>' attribute was set.
         *
         * @return true if the '<code>age</code>' attribute was set.
         */
        bool has_age() const {
          return Storage().isMember("age");
        }

        /**
         * Clears the '<code>age</code>' attribute.
         */
        void clear_age() {
          MutableStorage()->removeMember("age");
        }


        /**
         * Get the value of the '<code>age</code>' attribute.
         */
        int32 get_age() const {
          const Json::Value& storage = Storage("age");
          return client::JsonValueToCppValueHelper<int32 >(storage);
        }

        /**
         * Change the '<code>age</code>' attribute.
         *
         * Age of an object (in days). This condition is satisfied when an
         * object reaches the specified age.
         *
         * @param[in] value The new value.
         */
        void set_age(int32 value) {
          client::SetJsonValueFromCppValueHelper<int32 >(
            value, MutableStorage("age"));
        }

        /**
         * Determine if the '<code>createdBefore</code>' attribute was set.
         *
         * @return true if the '<code>createdBefore</code>' attribute was set.
         */
        bool has_created_before() const {
          return Storage().isMember("createdBefore");
        }

        /**
         * Clears the '<code>createdBefore</code>' attribute.
         */
        void clear_created_before() {
          MutableStorage()->removeMember("createdBefore");
        }


        /**
         * Get the value of the '<code>createdBefore</code>' attribute.
         */
        client::Date get_created_before() const {
          const Json::Value& storage = Storage("createdBefore");
          return client::JsonValueToCppValueHelper<client::Date >(storage);
        }

        /**
         * Change the '<code>createdBefore</code>' attribute.
         *
         * A date in RFC 3339 format with only the date part (for instance,
         * "2013-01-15"). This condition is satisfied when an object is created
         * before midnight of the specified date in UTC.
         *
         * @param[in] value The new value.
         */
        void set_created_before(client::Date value) {
          client::SetJsonValueFromCppValueHelper<client::Date >(
            value, MutableStorage("createdBefore"));
        }

        /**
         * Determine if the '<code>isLive</code>' attribute was set.
         *
         * @return true if the '<code>isLive</code>' attribute was set.
         */
        bool has_is_live() const {
          return Storage().isMember("isLive");
        }

        /**
         * Clears the '<code>isLive</code>' attribute.
         */
        void clear_is_live() {
          MutableStorage()->removeMember("isLive");
        }


        /**
         * Get the value of the '<code>isLive</code>' attribute.
         */
        bool get_is_live() const {
          const Json::Value& storage = Storage("isLive");
          return client::JsonValueToCppValueHelper<bool >(storage);
        }

        /**
         * Change the '<code>isLive</code>' attribute.
         *
         * Relevant only for versioned objects. If the value is true, this
         * condition matches live objects; if the value is false, it matches
         * archived objects.
         *
         * @param[in] value The new value.
         */
        void set_is_live(bool value) {
          client::SetJsonValueFromCppValueHelper<bool >(
            value, MutableStorage("isLive"));
        }

        /**
         * Determine if the '<code>matchesStorageClass</code>' attribute was
         * set.
         *
         * @return true if the '<code>matchesStorageClass</code>' attribute was
         * set.
         */
        bool has_matches_storage_class() const {
          return Storage().isMember("matchesStorageClass");
        }

        /**
         * Clears the '<code>matchesStorageClass</code>' attribute.
         */
        void clear_matches_storage_class() {
          MutableStorage()->removeMember("matchesStorageClass");
        }


        /**
         * Get a reference to the value of the
         * '<code>matchesStorageClass</code>' attribute.
         */
        const client::JsonCppArray<string > get_matches_storage_class() const {
           const Json::Value& storage = Storage("matchesStorageClass");
          return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
        }

        /**
         * Gets a reference to a mutable value of the
         * '<code>matchesStorageClass</code>' property.
         *
         * Objects having any of the storage classes specified by this condition
         * will be matched. Values include MULTI_REGIONAL, REGIONAL, NEARLINE,
         * COLDLINE, STANDARD, and DURABLE_REDUCED_AVAILABILITY.
         *
         * @return The result can be modified to change the attribute value.
         */
        client::JsonCppArray<string > mutable_matchesStorageClass() {
          Json::Value* storage = MutableStorage("matchesStorageClass");
          return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
        }

        /**
         * Determine if the '<code>numNewerVersions</code>' attribute was set.
         *
         * @return true if the '<code>numNewerVersions</code>' attribute was
         * set.
         */
        bool has_num_newer_versions() const {
          return Storage().isMember("numNewerVersions");
        }

        /**
         * Clears the '<code>numNewerVersions</code>' attribute.
         */
        void clear_num_newer_versions() {
          MutableStorage()->removeMember("numNewerVersions");
        }


        /**
         * Get the value of the '<code>numNewerVersions</code>' attribute.
         */
        int32 get_num_newer_versions() const {
          const Json::Value& storage = Storage("numNewerVersions");
          return client::JsonValueToCppValueHelper<int32 >(storage);
        }

        /**
         * Change the '<code>numNewerVersions</code>' attribute.
         *
         * Relevant only for versioned objects. If the value is N, this
         * condition is satisfied when there are at least N versions (including
         * the live version) newer than this version of the object.
         *
         * @param[in] value The new value.
         */
        void set_num_newer_versions(int32 value) {
          client::SetJsonValueFromCppValueHelper<int32 >(
            value, MutableStorage("numNewerVersions"));
        }

       private:
        void operator=(const BucketLifecycleRuleCondition&);
      };  // BucketLifecycleRuleCondition
      /**
       * Creates a new default instance.
       *
       * @return Ownership is passed back to the caller.
       */
      static BucketLifecycleRule* New();

      /**
       * Standard constructor for an immutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit BucketLifecycleRule(const Json::Value& storage);

      /**
       * Standard constructor for a mutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit BucketLifecycleRule(Json::Value* storage);

      /**
       * Standard destructor.
       */
      virtual ~BucketLifecycleRule();

      /**
       * Returns a string denoting the type of this data object.
       *
       * @return <code>google_storage_api::BucketLifecycleRule</code>
       */
      const StringPiece GetTypeName() const {
        return StringPiece("google_storage_api::BucketLifecycleRule");
      }

      /**
       * Determine if the '<code>action</code>' attribute was set.
       *
       * @return true if the '<code>action</code>' attribute was set.
       */
      bool has_action() const {
        return Storage().isMember("action");
      }

      /**
       * Clears the '<code>action</code>' attribute.
       */
      void clear_action() {
        MutableStorage()->removeMember("action");
      }


      /**
       * Get a reference to the value of the '<code>action</code>' attribute.
       */
      const BucketLifecycleRuleAction get_action() const {
         const Json::Value& storage = Storage("action");
        return client::JsonValueToCppValueHelper<BucketLifecycleRuleAction >(storage);
      }

      /**
       * Gets a reference to a mutable value of the '<code>action</code>'
       * property.
       *
       * The action to take.
       *
       * @return The result can be modified to change the attribute value.
       */
      BucketLifecycleRuleAction mutable_action() {
        Json::Value* storage = MutableStorage("action");
        return client::JsonValueToMutableCppValueHelper<BucketLifecycleRuleAction >(storage);
      }

      /**
       * Determine if the '<code>condition</code>' attribute was set.
       *
       * @return true if the '<code>condition</code>' attribute was set.
       */
      bool has_condition() const {
        return Storage().isMember("condition");
      }

      /**
       * Clears the '<code>condition</code>' attribute.
       */
      void clear_condition() {
        MutableStorage()->removeMember("condition");
      }


      /**
       * Get a reference to the value of the '<code>condition</code>' attribute.
       */
      const BucketLifecycleRuleCondition get_condition() const {
         const Json::Value& storage = Storage("condition");
        return client::JsonValueToCppValueHelper<BucketLifecycleRuleCondition >(storage);
      }

      /**
       * Gets a reference to a mutable value of the '<code>condition</code>'
       * property.
       *
       * The condition(s) under which the action will be taken.
       *
       * @return The result can be modified to change the attribute value.
       */
      BucketLifecycleRuleCondition mutable_condition() {
        Json::Value* storage = MutableStorage("condition");
        return client::JsonValueToMutableCppValueHelper<BucketLifecycleRuleCondition >(storage);
      }

     private:
      void operator=(const BucketLifecycleRule&);
    };  // BucketLifecycleRule
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketLifecycle* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketLifecycle(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketLifecycle(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketLifecycle();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketLifecycle</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketLifecycle");
    }

    /**
     * Determine if the '<code>rule</code>' attribute was set.
     *
     * @return true if the '<code>rule</code>' attribute was set.
     */
    bool has_rule() const {
      return Storage().isMember("rule");
    }

    /**
     * Clears the '<code>rule</code>' attribute.
     */
    void clear_rule() {
      MutableStorage()->removeMember("rule");
    }


    /**
     * Get a reference to the value of the '<code>rule</code>' attribute.
     */
    const client::JsonCppArray<BucketLifecycleRule > get_rule() const {
       const Json::Value& storage = Storage("rule");
      return client::JsonValueToCppValueHelper<client::JsonCppArray<BucketLifecycleRule > >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>rule</code>' property.
     *
     * A lifecycle management rule, which is made of an action to take and the
     * condition(s) under which the action will be taken.
     *
     * @return The result can be modified to change the attribute value.
     */
    client::JsonCppArray<BucketLifecycleRule > mutable_rule() {
      Json::Value* storage = MutableStorage("rule");
      return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<BucketLifecycleRule > >(storage);
    }

   private:
    void operator=(const BucketLifecycle&);
  };  // BucketLifecycle
  /**
   * The bucket's logging configuration, which defines the destination bucket
   * and optional name prefix for the current bucket's logs.
   *
   * @ingroup DataObject
   */
  class BucketLogging : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketLogging* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketLogging(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketLogging(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketLogging();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketLogging</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketLogging");
    }

    /**
     * Determine if the '<code>logBucket</code>' attribute was set.
     *
     * @return true if the '<code>logBucket</code>' attribute was set.
     */
    bool has_log_bucket() const {
      return Storage().isMember("logBucket");
    }

    /**
     * Clears the '<code>logBucket</code>' attribute.
     */
    void clear_log_bucket() {
      MutableStorage()->removeMember("logBucket");
    }


    /**
     * Get the value of the '<code>logBucket</code>' attribute.
     */
    const StringPiece get_log_bucket() const {
      const Json::Value& v = Storage("logBucket");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>logBucket</code>' attribute.
     *
     * The destination bucket where the current bucket's logs should be placed.
     *
     * @param[in] value The new value.
     */
    void set_log_bucket(const StringPiece& value) {
      *MutableStorage("logBucket") = value.data();
    }

    /**
     * Determine if the '<code>logObjectPrefix</code>' attribute was set.
     *
     * @return true if the '<code>logObjectPrefix</code>' attribute was set.
     */
    bool has_log_object_prefix() const {
      return Storage().isMember("logObjectPrefix");
    }

    /**
     * Clears the '<code>logObjectPrefix</code>' attribute.
     */
    void clear_log_object_prefix() {
      MutableStorage()->removeMember("logObjectPrefix");
    }


    /**
     * Get the value of the '<code>logObjectPrefix</code>' attribute.
     */
    const StringPiece get_log_object_prefix() const {
      const Json::Value& v = Storage("logObjectPrefix");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>logObjectPrefix</code>' attribute.
     *
     * A prefix for log object names.
     *
     * @param[in] value The new value.
     */
    void set_log_object_prefix(const StringPiece& value) {
      *MutableStorage("logObjectPrefix") = value.data();
    }

   private:
    void operator=(const BucketLogging&);
  };  // BucketLogging
  /**
   * The owner of the bucket. This is always the project team's owner group.
   *
   * @ingroup DataObject
   */
  class BucketOwner : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketOwner* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketOwner(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketOwner(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketOwner();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketOwner</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketOwner");
    }

    /**
     * Determine if the '<code>entity</code>' attribute was set.
     *
     * @return true if the '<code>entity</code>' attribute was set.
     */
    bool has_entity() const {
      return Storage().isMember("entity");
    }

    /**
     * Clears the '<code>entity</code>' attribute.
     */
    void clear_entity() {
      MutableStorage()->removeMember("entity");
    }


    /**
     * Get the value of the '<code>entity</code>' attribute.
     */
    const StringPiece get_entity() const {
      const Json::Value& v = Storage("entity");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>entity</code>' attribute.
     *
     * The entity, in the form project-owner-projectId.
     *
     * @param[in] value The new value.
     */
    void set_entity(const StringPiece& value) {
      *MutableStorage("entity") = value.data();
    }

    /**
     * Determine if the '<code>entityId</code>' attribute was set.
     *
     * @return true if the '<code>entityId</code>' attribute was set.
     */
    bool has_entity_id() const {
      return Storage().isMember("entityId");
    }

    /**
     * Clears the '<code>entityId</code>' attribute.
     */
    void clear_entity_id() {
      MutableStorage()->removeMember("entityId");
    }


    /**
     * Get the value of the '<code>entityId</code>' attribute.
     */
    const StringPiece get_entity_id() const {
      const Json::Value& v = Storage("entityId");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>entityId</code>' attribute.
     *
     * The ID for the entity.
     *
     * @param[in] value The new value.
     */
    void set_entity_id(const StringPiece& value) {
      *MutableStorage("entityId") = value.data();
    }

   private:
    void operator=(const BucketOwner&);
  };  // BucketOwner
  /**
   * The bucket's versioning configuration.
   *
   * @ingroup DataObject
   */
  class BucketVersioning : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketVersioning* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketVersioning(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketVersioning(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketVersioning();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketVersioning</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketVersioning");
    }

    /**
     * Determine if the '<code>enabled</code>' attribute was set.
     *
     * @return true if the '<code>enabled</code>' attribute was set.
     */
    bool has_enabled() const {
      return Storage().isMember("enabled");
    }

    /**
     * Clears the '<code>enabled</code>' attribute.
     */
    void clear_enabled() {
      MutableStorage()->removeMember("enabled");
    }


    /**
     * Get the value of the '<code>enabled</code>' attribute.
     */
    bool get_enabled() const {
      const Json::Value& storage = Storage("enabled");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>enabled</code>' attribute.
     *
     * While set to true, versioning is fully enabled for this bucket.
     *
     * @param[in] value The new value.
     */
    void set_enabled(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("enabled"));
    }

   private:
    void operator=(const BucketVersioning&);
  };  // BucketVersioning
  /**
   * The bucket's website configuration, controlling how the service behaves
   * when accessing bucket contents as a web site. See the Static Website
   * Examples for more information.
   *
   * @ingroup DataObject
   */
  class BucketWebsite : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static BucketWebsite* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketWebsite(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit BucketWebsite(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~BucketWebsite();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_storage_api::BucketWebsite</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_storage_api::BucketWebsite");
    }

    /**
     * Determine if the '<code>mainPageSuffix</code>' attribute was set.
     *
     * @return true if the '<code>mainPageSuffix</code>' attribute was set.
     */
    bool has_main_page_suffix() const {
      return Storage().isMember("mainPageSuffix");
    }

    /**
     * Clears the '<code>mainPageSuffix</code>' attribute.
     */
    void clear_main_page_suffix() {
      MutableStorage()->removeMember("mainPageSuffix");
    }


    /**
     * Get the value of the '<code>mainPageSuffix</code>' attribute.
     */
    const StringPiece get_main_page_suffix() const {
      const Json::Value& v = Storage("mainPageSuffix");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>mainPageSuffix</code>' attribute.
     *
     * If the requested object path is missing, the service will ensure the path
     * has a trailing '/', append this suffix, and attempt to retrieve the
     * resulting object. This allows the creation of index.html objects to
     * represent directory pages.
     *
     * @param[in] value The new value.
     */
    void set_main_page_suffix(const StringPiece& value) {
      *MutableStorage("mainPageSuffix") = value.data();
    }

    /**
     * Determine if the '<code>notFoundPage</code>' attribute was set.
     *
     * @return true if the '<code>notFoundPage</code>' attribute was set.
     */
    bool has_not_found_page() const {
      return Storage().isMember("notFoundPage");
    }

    /**
     * Clears the '<code>notFoundPage</code>' attribute.
     */
    void clear_not_found_page() {
      MutableStorage()->removeMember("notFoundPage");
    }


    /**
     * Get the value of the '<code>notFoundPage</code>' attribute.
     */
    const StringPiece get_not_found_page() const {
      const Json::Value& v = Storage("notFoundPage");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>notFoundPage</code>' attribute.
     *
     * If the requested object path is missing, and any mainPageSuffix object is
     * missing, if applicable, the service will return the named object from
     * this bucket as the content for a 404 Not Found result.
     *
     * @param[in] value The new value.
     */
    void set_not_found_page(const StringPiece& value) {
      *MutableStorage("notFoundPage") = value.data();
    }

   private:
    void operator=(const BucketWebsite&);
  };  // BucketWebsite
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static Bucket* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Bucket(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Bucket(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~Bucket();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_storage_api::Bucket</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_storage_api::Bucket");
  }

  /**
   * Determine if the '<code>acl</code>' attribute was set.
   *
   * @return true if the '<code>acl</code>' attribute was set.
   */
  bool has_acl() const {
    return Storage().isMember("acl");
  }

  /**
   * Clears the '<code>acl</code>' attribute.
   */
  void clear_acl() {
    MutableStorage()->removeMember("acl");
  }


  /**
   * Get a reference to the value of the '<code>acl</code>' attribute.
   */
  const client::JsonCppArray<BucketAccessControl > get_acl() const;

  /**
   * Gets a reference to a mutable value of the '<code>acl</code>' property.
   *
   * Access controls on the bucket.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<BucketAccessControl > mutable_acl();

  /**
   * Determine if the '<code>billing</code>' attribute was set.
   *
   * @return true if the '<code>billing</code>' attribute was set.
   */
  bool has_billing() const {
    return Storage().isMember("billing");
  }

  /**
   * Clears the '<code>billing</code>' attribute.
   */
  void clear_billing() {
    MutableStorage()->removeMember("billing");
  }


  /**
   * Get a reference to the value of the '<code>billing</code>' attribute.
   */
  const BucketBilling get_billing() const {
     const Json::Value& storage = Storage("billing");
    return client::JsonValueToCppValueHelper<BucketBilling >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>billing</code>' property.
   *
   * The bucket's billing configuration.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketBilling mutable_billing() {
    Json::Value* storage = MutableStorage("billing");
    return client::JsonValueToMutableCppValueHelper<BucketBilling >(storage);
  }

  /**
   * Determine if the '<code>cors</code>' attribute was set.
   *
   * @return true if the '<code>cors</code>' attribute was set.
   */
  bool has_cors() const {
    return Storage().isMember("cors");
  }

  /**
   * Clears the '<code>cors</code>' attribute.
   */
  void clear_cors() {
    MutableStorage()->removeMember("cors");
  }


  /**
   * Get a reference to the value of the '<code>cors</code>' attribute.
   */
  const client::JsonCppArray<BucketCors > get_cors() const {
     const Json::Value& storage = Storage("cors");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<BucketCors > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>cors</code>' property.
   *
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<BucketCors > mutable_cors() {
    Json::Value* storage = MutableStorage("cors");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<BucketCors > >(storage);
  }

  /**
   * Determine if the '<code>defaultObjectAcl</code>' attribute was set.
   *
   * @return true if the '<code>defaultObjectAcl</code>' attribute was set.
   */
  bool has_default_object_acl() const {
    return Storage().isMember("defaultObjectAcl");
  }

  /**
   * Clears the '<code>defaultObjectAcl</code>' attribute.
   */
  void clear_default_object_acl() {
    MutableStorage()->removeMember("defaultObjectAcl");
  }


  /**
   * Get a reference to the value of the '<code>defaultObjectAcl</code>'
   * attribute.
   */
  const client::JsonCppArray<ObjectAccessControl > get_default_object_acl() const;

  /**
   * Gets a reference to a mutable value of the '<code>defaultObjectAcl</code>'
   * property.
   *
   * Default access controls to apply to new objects when no ACL is provided.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<ObjectAccessControl > mutable_defaultObjectAcl();

  /**
   * Determine if the '<code>etag</code>' attribute was set.
   *
   * @return true if the '<code>etag</code>' attribute was set.
   */
  bool has_etag() const {
    return Storage().isMember("etag");
  }

  /**
   * Clears the '<code>etag</code>' attribute.
   */
  void clear_etag() {
    MutableStorage()->removeMember("etag");
  }


  /**
   * Get the value of the '<code>etag</code>' attribute.
   */
  const StringPiece get_etag() const {
    const Json::Value& v = Storage("etag");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>etag</code>' attribute.
   *
   * HTTP 1.1 Entity tag for the bucket.
   *
   * @param[in] value The new value.
   */
  void set_etag(const StringPiece& value) {
    *MutableStorage("etag") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * The ID of the bucket. For buckets, the id and name properities are the
   * same.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * The kind of item this is. For buckets, this is always storage#bucket.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>labels</code>' attribute was set.
   *
   * @return true if the '<code>labels</code>' attribute was set.
   */
  bool has_labels() const {
    return Storage().isMember("labels");
  }

  /**
   * Clears the '<code>labels</code>' attribute.
   */
  void clear_labels() {
    MutableStorage()->removeMember("labels");
  }


  /**
   * Get a reference to the value of the '<code>labels</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_labels() const {
     const Json::Value& storage = Storage("labels");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>labels</code>' property.
   *
   * User-provided labels, in key/value pairs.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_labels() {
    Json::Value* storage = MutableStorage("labels");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>lifecycle</code>' attribute was set.
   *
   * @return true if the '<code>lifecycle</code>' attribute was set.
   */
  bool has_lifecycle() const {
    return Storage().isMember("lifecycle");
  }

  /**
   * Clears the '<code>lifecycle</code>' attribute.
   */
  void clear_lifecycle() {
    MutableStorage()->removeMember("lifecycle");
  }


  /**
   * Get a reference to the value of the '<code>lifecycle</code>' attribute.
   */
  const BucketLifecycle get_lifecycle() const {
     const Json::Value& storage = Storage("lifecycle");
    return client::JsonValueToCppValueHelper<BucketLifecycle >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>lifecycle</code>'
   * property.
   *
   * The bucket's lifecycle configuration. See lifecycle management for more
   * information.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketLifecycle mutable_lifecycle() {
    Json::Value* storage = MutableStorage("lifecycle");
    return client::JsonValueToMutableCppValueHelper<BucketLifecycle >(storage);
  }

  /**
   * Determine if the '<code>location</code>' attribute was set.
   *
   * @return true if the '<code>location</code>' attribute was set.
   */
  bool has_location() const {
    return Storage().isMember("location");
  }

  /**
   * Clears the '<code>location</code>' attribute.
   */
  void clear_location() {
    MutableStorage()->removeMember("location");
  }


  /**
   * Get the value of the '<code>location</code>' attribute.
   */
  const StringPiece get_location() const {
    const Json::Value& v = Storage("location");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>location</code>' attribute.
   *
   * The location of the bucket. Object data for objects in the bucket resides
   * in physical storage within this region. Defaults to US. See the developer's
   * guide for the authoritative list.
   *
   * @param[in] value The new value.
   */
  void set_location(const StringPiece& value) {
    *MutableStorage("location") = value.data();
  }

  /**
   * Determine if the '<code>logging</code>' attribute was set.
   *
   * @return true if the '<code>logging</code>' attribute was set.
   */
  bool has_logging() const {
    return Storage().isMember("logging");
  }

  /**
   * Clears the '<code>logging</code>' attribute.
   */
  void clear_logging() {
    MutableStorage()->removeMember("logging");
  }


  /**
   * Get a reference to the value of the '<code>logging</code>' attribute.
   */
  const BucketLogging get_logging() const {
     const Json::Value& storage = Storage("logging");
    return client::JsonValueToCppValueHelper<BucketLogging >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>logging</code>' property.
   *
   * The bucket's logging configuration, which defines the destination bucket
   * and optional name prefix for the current bucket's logs.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketLogging mutable_logging() {
    Json::Value* storage = MutableStorage("logging");
    return client::JsonValueToMutableCppValueHelper<BucketLogging >(storage);
  }

  /**
   * Determine if the '<code>metageneration</code>' attribute was set.
   *
   * @return true if the '<code>metageneration</code>' attribute was set.
   */
  bool has_metageneration() const {
    return Storage().isMember("metageneration");
  }

  /**
   * Clears the '<code>metageneration</code>' attribute.
   */
  void clear_metageneration() {
    MutableStorage()->removeMember("metageneration");
  }


  /**
   * Get the value of the '<code>metageneration</code>' attribute.
   */
  int64 get_metageneration() const {
    const Json::Value& storage = Storage("metageneration");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>metageneration</code>' attribute.
   *
   * The metadata generation of this bucket.
   *
   * @param[in] value The new value.
   */
  void set_metageneration(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("metageneration"));
  }

  /**
   * Determine if the '<code>name</code>' attribute was set.
   *
   * @return true if the '<code>name</code>' attribute was set.
   */
  bool has_name() const {
    return Storage().isMember("name");
  }

  /**
   * Clears the '<code>name</code>' attribute.
   */
  void clear_name() {
    MutableStorage()->removeMember("name");
  }


  /**
   * Get the value of the '<code>name</code>' attribute.
   */
  const StringPiece get_name() const {
    const Json::Value& v = Storage("name");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>name</code>' attribute.
   *
   * The name of the bucket.
   *
   * @param[in] value The new value.
   */
  void set_name(const StringPiece& value) {
    *MutableStorage("name") = value.data();
  }

  /**
   * Determine if the '<code>owner</code>' attribute was set.
   *
   * @return true if the '<code>owner</code>' attribute was set.
   */
  bool has_owner() const {
    return Storage().isMember("owner");
  }

  /**
   * Clears the '<code>owner</code>' attribute.
   */
  void clear_owner() {
    MutableStorage()->removeMember("owner");
  }


  /**
   * Get a reference to the value of the '<code>owner</code>' attribute.
   */
  const BucketOwner get_owner() const {
     const Json::Value& storage = Storage("owner");
    return client::JsonValueToCppValueHelper<BucketOwner >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>owner</code>' property.
   *
   * The owner of the bucket. This is always the project team's owner group.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketOwner mutable_owner() {
    Json::Value* storage = MutableStorage("owner");
    return client::JsonValueToMutableCppValueHelper<BucketOwner >(storage);
  }

  /**
   * Determine if the '<code>projectNumber</code>' attribute was set.
   *
   * @return true if the '<code>projectNumber</code>' attribute was set.
   */
  bool has_project_number() const {
    return Storage().isMember("projectNumber");
  }

  /**
   * Clears the '<code>projectNumber</code>' attribute.
   */
  void clear_project_number() {
    MutableStorage()->removeMember("projectNumber");
  }


  /**
   * Get the value of the '<code>projectNumber</code>' attribute.
   */
  uint64 get_project_number() const {
    const Json::Value& storage = Storage("projectNumber");
    return client::JsonValueToCppValueHelper<uint64 >(storage);
  }

  /**
   * Change the '<code>projectNumber</code>' attribute.
   *
   * The project number of the project the bucket belongs to.
   *
   * @param[in] value The new value.
   */
  void set_project_number(uint64 value) {
    client::SetJsonValueFromCppValueHelper<uint64 >(
      value, MutableStorage("projectNumber"));
  }

  /**
   * Determine if the '<code>selfLink</code>' attribute was set.
   *
   * @return true if the '<code>selfLink</code>' attribute was set.
   */
  bool has_self_link() const {
    return Storage().isMember("selfLink");
  }

  /**
   * Clears the '<code>selfLink</code>' attribute.
   */
  void clear_self_link() {
    MutableStorage()->removeMember("selfLink");
  }


  /**
   * Get the value of the '<code>selfLink</code>' attribute.
   */
  const StringPiece get_self_link() const {
    const Json::Value& v = Storage("selfLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>selfLink</code>' attribute.
   *
   * The URI of this bucket.
   *
   * @param[in] value The new value.
   */
  void set_self_link(const StringPiece& value) {
    *MutableStorage("selfLink") = value.data();
  }

  /**
   * Determine if the '<code>storageClass</code>' attribute was set.
   *
   * @return true if the '<code>storageClass</code>' attribute was set.
   */
  bool has_storage_class() const {
    return Storage().isMember("storageClass");
  }

  /**
   * Clears the '<code>storageClass</code>' attribute.
   */
  void clear_storage_class() {
    MutableStorage()->removeMember("storageClass");
  }


  /**
   * Get the value of the '<code>storageClass</code>' attribute.
   */
  const StringPiece get_storage_class() const {
    const Json::Value& v = Storage("storageClass");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>storageClass</code>' attribute.
   *
   * The bucket's default storage class, used whenever no storageClass is
   * specified for a newly-created object. This defines how objects in the
   * bucket are stored and determines the SLA and the cost of storage. Values
   * include MULTI_REGIONAL, REGIONAL, STANDARD, NEARLINE, COLDLINE, and
   * DURABLE_REDUCED_AVAILABILITY. If this value is not specified when the
   * bucket is created, it will default to STANDARD. For more information, see
   * storage classes.
   *
   * @param[in] value The new value.
   */
  void set_storage_class(const StringPiece& value) {
    *MutableStorage("storageClass") = value.data();
  }

  /**
   * Determine if the '<code>timeCreated</code>' attribute was set.
   *
   * @return true if the '<code>timeCreated</code>' attribute was set.
   */
  bool has_time_created() const {
    return Storage().isMember("timeCreated");
  }

  /**
   * Clears the '<code>timeCreated</code>' attribute.
   */
  void clear_time_created() {
    MutableStorage()->removeMember("timeCreated");
  }


  /**
   * Get the value of the '<code>timeCreated</code>' attribute.
   */
  client::DateTime get_time_created() const {
    const Json::Value& storage = Storage("timeCreated");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>timeCreated</code>' attribute.
   *
   * The creation time of the bucket in RFC 3339 format.
   *
   * @param[in] value The new value.
   */
  void set_time_created(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("timeCreated"));
  }

  /**
   * Determine if the '<code>updated</code>' attribute was set.
   *
   * @return true if the '<code>updated</code>' attribute was set.
   */
  bool has_updated() const {
    return Storage().isMember("updated");
  }

  /**
   * Clears the '<code>updated</code>' attribute.
   */
  void clear_updated() {
    MutableStorage()->removeMember("updated");
  }


  /**
   * Get the value of the '<code>updated</code>' attribute.
   */
  client::DateTime get_updated() const {
    const Json::Value& storage = Storage("updated");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>updated</code>' attribute.
   *
   * The modification time of the bucket in RFC 3339 format.
   *
   * @param[in] value The new value.
   */
  void set_updated(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("updated"));
  }

  /**
   * Determine if the '<code>versioning</code>' attribute was set.
   *
   * @return true if the '<code>versioning</code>' attribute was set.
   */
  bool has_versioning() const {
    return Storage().isMember("versioning");
  }

  /**
   * Clears the '<code>versioning</code>' attribute.
   */
  void clear_versioning() {
    MutableStorage()->removeMember("versioning");
  }


  /**
   * Get a reference to the value of the '<code>versioning</code>' attribute.
   */
  const BucketVersioning get_versioning() const {
     const Json::Value& storage = Storage("versioning");
    return client::JsonValueToCppValueHelper<BucketVersioning >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>versioning</code>'
   * property.
   *
   * The bucket's versioning configuration.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketVersioning mutable_versioning() {
    Json::Value* storage = MutableStorage("versioning");
    return client::JsonValueToMutableCppValueHelper<BucketVersioning >(storage);
  }

  /**
   * Determine if the '<code>website</code>' attribute was set.
   *
   * @return true if the '<code>website</code>' attribute was set.
   */
  bool has_website() const {
    return Storage().isMember("website");
  }

  /**
   * Clears the '<code>website</code>' attribute.
   */
  void clear_website() {
    MutableStorage()->removeMember("website");
  }


  /**
   * Get a reference to the value of the '<code>website</code>' attribute.
   */
  const BucketWebsite get_website() const {
     const Json::Value& storage = Storage("website");
    return client::JsonValueToCppValueHelper<BucketWebsite >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>website</code>' property.
   *
   * The bucket's website configuration, controlling how the service behaves
   * when accessing bucket contents as a web site. See the Static Website
   * Examples for more information.
   *
   * @return The result can be modified to change the attribute value.
   */
  BucketWebsite mutable_website() {
    Json::Value* storage = MutableStorage("website");
    return client::JsonValueToMutableCppValueHelper<BucketWebsite >(storage);
  }

 private:
  void operator=(const Bucket&);
};  // Bucket
}  // namespace google_storage_api
#endif  // GOOGLE_STORAGE_API_BUCKET_H_
